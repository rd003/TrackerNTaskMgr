using System.Data;
using System.Reflection.Metadata;

using Microsoft.Extensions.Options;

using MongoDB.Bson;
using MongoDB.Driver;

using TrackerNTaskMgr.Api.DTOs;
using TrackerNTaskMgr.Api.Entities;
using TrackerNTaskMgr.Api.Mappers;
using TrackerNTaskMgr.Api.Settings;

namespace TrackerNTaskMgr.Api.Services;

public class TaskService : ITaskService
{
    private readonly IMongoCollection<TaskItem> _taskCollection;
    public TaskService(IOptions<DatabaseSettings> databaseSettings)
    {
        var client = new MongoClient(databaseSettings.Value.ConnectionString);
        var database = client.GetDatabase(databaseSettings.Value.DatabaseName);
        _taskCollection = database.GetCollection<TaskItem>(databaseSettings.Value.TaskItemCollectionName);
    }

    public async Task<string> CreateTaskAsync(TaskCreateDTO taskCreate)
    {
        var taskItem = taskCreate.ToTaskItem();
        await _taskCollection.InsertOneAsync(taskItem);
        return taskItem.Id;
    }

    public async Task UpdateTaskAsync(TaskUpdateDto taskToUpdate)
    {
        var task = taskToUpdate.ToTaskItem();
        await _taskCollection.ReplaceOneAsync(x => x.Id == task.Id, task);
    }

    // This method is mostly generated by claude AI. It might not contain best practices.  
    public async Task<TaskReadDTO?> GetTaskByTaskIdAsync(string taskId)
    {
        var pipleline = new BsonDocument[]{
            // match specific task
           new BsonDocument("$match",new BsonDocument("_id",ObjectId.Parse(taskId))),

            // Lookup TaskHeader to get header title
            new BsonDocument("$lookup", new BsonDocument
            {
                { "from", "taskHeaders" }, // Adjust collection name as needed
                { "localField", "taskHeaderId" },
                { "foreignField", "_id" },
                { "as", "taskHeader" }
            }),

            // Unwind the taskHeader array (should be single document)
            new BsonDocument("$unwind", new BsonDocument
            {
                { "path", "$taskHeader" },
                { "preserveNullAndEmptyArrays", false }
            }),

            // Project the fields we need
            new BsonDocument("$project", new BsonDocument
            {
                { "_id", 1 },
                { "taskHeaderId", 1 },
                { "title", 1 },
                { "uri", 1 },
                { "priority", 1 },
                { "status", 1 },
                { "deadline", 1 },
                { "scheduledAt", 1 },
                { "displayAtBoard", 1 },
                { "subTasks", 1 },
                { "tags", 1 },
                { "taskHeaderTitle", "$taskHeader.taskHeaderTitle" }
            })
        };

        var taskItems = await _taskCollection.AggregateAsync<BsonDocument>(pipleline);
        var taskDocument = await taskItems.FirstOrDefaultAsync();

        if (taskDocument is null) return null;

        // Map BsonDocument to TaskReadDTO
        var taskReadDto = new TaskReadDTO
        {
            TaskId = taskDocument["_id"].AsObjectId.ToString(),
            TaskHeaderId = taskDocument["taskHeaderId"].AsString,
            TaskTitle = taskDocument["title"].AsString,
            TaskUri = taskDocument.Contains("uri") && !taskDocument["uri"].IsBsonNull
                ? taskDocument["uri"].AsString : null,
            TaskPriorityId = (byte)taskDocument["priority"].AsInt32,
            TaskStatusId = (byte)taskDocument["status"].AsInt32,
            Deadline = taskDocument.Contains("deadline") && !taskDocument["deadline"].IsBsonNull
                ? taskDocument["deadline"].ToUniversalTime() : null,
            ScheduledAt = taskDocument.Contains("scheduledAt") && !taskDocument["scheduledAt"].IsBsonNull
                ? taskDocument["scheduledAt"].ToUniversalTime() : null,
            DisplayAtBoard = taskDocument["displayAtBoard"].AsBoolean,
            TaskHeaderTitle = taskDocument["taskHeaderTitle"].AsString,
            Tags = taskDocument["tags"].AsBsonArray.Select(tag => tag.AsString).ToList(),

            // Map SubTasks
            SubTasks = taskDocument["subTasks"].AsBsonArray.Select(subTask => new SubTaskReadDto
            {
                SubTaskTitle = subTask["subTaskTitle"].AsString,
                SubTaskUri = subTask.AsBsonDocument.Contains("subTaskUri") && !subTask["subTaskUri"].IsBsonNull
                    ? subTask["subTaskUri"].AsString : null,
            }).ToList()
        };

        return taskReadDto;
    }

    public async Task<IEnumerable<TaskReadDTO>> GetTasksAsync(GetTasksParams parameters)
    {
        throw new NotImplementedException();
    }


    public async Task<bool> IsTaskExists(string taskId)
    {
        var task = await _taskCollection.Find(x => x.Id == taskId).FirstOrDefaultAsync();
        return task != null;
    }

    public async Task DeleteTask(string taskId)
    {
        var filter = Builders<TaskItem>.Filter.Eq(x => x.Id, taskId);
        var update = Builders<TaskItem>.Update.Set(x => x.DeletedAt, DateTimeOffset.UtcNow);
        await _taskCollection.UpdateOneAsync(filter, update);
    }

    public async Task<IEnumerable<DisplayBoardTaskDto>> GetDisplayBoardTasksAsync()
    {
        // Get task where display at board is true and order it by deadline desc
        var filter = Builders<TaskItem>.Filter.And(
            Builders<TaskItem>.Filter.Eq(x => x.DeletedAt, null),
            Builders<TaskItem>.Filter.Eq(x => x.DisplayAtBoard, true)
        );
        var sort = Builders<TaskItem>.Sort.Descending(x => x.Deadline);

        var tasks = await _taskCollection
                    .Find(filter)
                    .Sort(sort)
                    .ToListAsync();
        return tasks.Select(
            t => new DisplayBoardTaskDto
            {
                TaskId = t.Id,
                TaskTitle = t.Title,
                TaskPriorityName = t.Priority.ToString(),
                TaskStatusName = t.Status.ToString(),
                ScheduledAt = t.ScheduledAt,
                Deadline = t.Deadline
            }
        ).ToList();
    }

    public async Task<IEnumerable<TaskStatusSelect>> GetTaskStatusesAsync()
    {
        var statuses = Enum.GetValues(typeof(Constants.TaskStatus))
         .Cast<Constants.TaskStatus>()
         .Select(status => new TaskStatusSelect(
             (byte)status,
             status.ToString()
         ));

        return await Task.FromResult(statuses);
    }

    public async Task<IEnumerable<TaskPrioritySelect>> GetTaskPrioritiesAsync()
    {
        var taskPriorities = Enum.GetValues(typeof(Constants.TaskPriority))
                 .Cast<Constants.TaskPriority>()
                 .Select(status => new TaskPrioritySelect(
                     (byte)status,
                     status.ToString()
                 ));

        return await Task.FromResult(taskPriorities);
    }

    public async Task<IEnumerable<TagReadDto>> GetAllTagsAsync()
    {
        var distinctTags = await _taskCollection
       .DistinctAsync<string>("tags", Builders<TaskItem>.Filter.Empty);

        var tagList = await distinctTags.ToListAsync();

        return tagList.Select(tag => new TagReadDto { TagName = tag });
    }
}

