using System.Data;

using Microsoft.Extensions.Options;

using MongoDB.Bson;
using MongoDB.Driver;

using TrackerNTaskMgr.Api.DTOs;
using TrackerNTaskMgr.Api.Entities;
using TrackerNTaskMgr.Api.Mappers;
using TrackerNTaskMgr.Api.Settings;

namespace TrackerNTaskMgr.Api.Services;

public class TaskService : ITaskService
{
    private readonly IMongoCollection<TaskItem> _taskCollection;
    public TaskService(IOptions<DatabaseSettings> databaseSettings)
    {
        var client = new MongoClient(databaseSettings.Value.ConnectionString);
        var database = client.GetDatabase(databaseSettings.Value.DatabaseName);
        _taskCollection = database.GetCollection<TaskItem>(databaseSettings.Value.TaskItemCollectionName);
    }

    public async Task<string> CreateTaskAsync(TaskCreateDTO taskCreate)
    {
        var taskItem = taskCreate.ToTaskItem();
        await _taskCollection.InsertOneAsync(taskItem);
        return taskItem.Id;
    }

    public async Task UpdateTaskAsync(TaskUpdateDto taskToUpdate)
    {
        var task = taskToUpdate.ToTaskItem();
        await _taskCollection.ReplaceOneAsync(x => x.Id == task.Id, task);
    }

    // This method is mostly generated by claude AI. It might not contain best practices.  
    public async Task<TaskReadDTO?> GetTaskByTaskIdAsync(string taskId)
    {
        var pipleline = new BsonDocument[]{
            // match specific task
            new BsonDocument("$match", new BsonDocument
        {
            { "_id", ObjectId.Parse(taskId) },
            { "deletedAt", BsonNull.Value }
        }),

            // Lookup TaskHeader to get header title
            new BsonDocument("$lookup", new BsonDocument
            {
                { "from", "taskHeaders" }, // Adjust collection name as needed
                { "localField", "taskHeaderId" },
                { "foreignField", "_id" },
                { "as", "taskHeader" }
            }),

            // taskHeader is array, so we need to flatten it
            new BsonDocument("$unwind", new BsonDocument
            {
                { "path", "$taskHeader" },
                { "preserveNullAndEmptyArrays", false }
            }),

            // Project the fields we need
            new BsonDocument("$project", new BsonDocument
            {
                { "_id", 1 },
                { "taskHeaderId", 1 },
                { "title", 1 },
                { "uri", 1 },
                { "priority", 1 },
                { "status", 1 },
                { "deadline", 1 },
                { "scheduledAt", 1 },
                { "displayAtBoard", 1 },
                { "subTasks", 1 },
                { "tags", 1 },
                { "taskHeaderTitle", "$taskHeader.taskHeaderTitle" }
            })
        };

        var taskItems = await _taskCollection.AggregateAsync<BsonDocument>(pipleline);
        var taskDocument = await taskItems.FirstOrDefaultAsync();

        if (taskDocument is null) return null;

        // Map BsonDocument to TaskReadDTO
        var taskReadDto = MapBsonDocumentToTaskReadDTO(taskDocument);

        return taskReadDto;
    }

    public async Task<IEnumerable<TaskReadDTO>> GetTasksAsync(GetTasksParams parameters)
    {

        var pipeline = new List<BsonDocument>();

        // Step 1: Build match conditions
        var matchConditions = new List<BsonDocument>();

        // Filter by TaskHeaderId if provided
        if (!string.IsNullOrEmpty(parameters.TaskHeaderId) && ObjectId.TryParse(parameters.TaskHeaderId, out _))
        {
            matchConditions.Add(new BsonDocument("taskHeaderId", ObjectId.Parse(parameters.TaskHeaderId)));
        }

        // Filter by TaskPriorityId if provided
        if (parameters.TaskPriorityId.HasValue)
        {
            matchConditions.Add(new BsonDocument("priority", parameters.TaskPriorityId));
        }

        // Filter by Tag if provided (tags are stored as array of strings)
        if (!string.IsNullOrEmpty(parameters.Tag))
        {
            matchConditions.Add(new BsonDocument("tags", parameters.Tag));
        }

        // Exclude deleted tasks 
        matchConditions.Add(new BsonDocument("deletedAt", BsonNull.Value));

        // Add match stage if we have conditions
        if (matchConditions.Any())
        {
            var matchStage = matchConditions.Count == 1
                ? matchConditions.First()
                : new BsonDocument("$and", new BsonArray(matchConditions));

            pipeline.Add(new BsonDocument("$match", matchStage));
        }


        // Step 2: Lookup TaskHeader to get header title
        pipeline.Add(new BsonDocument("$lookup", new BsonDocument
        {
            { "from", "taskHeaders" }, // Adjust collection name as needed
            { "localField", "taskHeaderId" },
            { "foreignField", "_id" },
            { "as", "taskHeader" }
        }));

        // Step 3: Unwind taskHeader (handle cases where header might not exist)
        pipeline.Add(new BsonDocument("$unwind", new BsonDocument
        {
            { "path", "$taskHeader" },
            { "preserveNullAndEmptyArrays", true } // Keep tasks even if header is missing
        }));

        // Step 4: Project the fields we need
        pipeline.Add(new BsonDocument("$project", new BsonDocument
        {
            { "_id", 1 },
            { "taskHeaderId", 1 },
            { "title", 1 },
            { "uri", 1 },
            { "priority", 1 },
            { "status", 1 },
            { "deadline", 1 },
            { "scheduledAt", 1 },
            { "displayAtBoard", 1 },
            { "subTasks", 1 },
            { "tags", 1 },
            { "createdAt", 1 },
            { "updatedAt", 1 },
            { "taskHeaderTitle", new BsonDocument("$ifNull", new BsonArray { "$taskHeader.taskHeaderTitle", "Unknown Header" }) }
        }));

        // Step 5: Add sorting
        if (!string.IsNullOrEmpty(parameters.SortBy))
        {
            var sortDirection = string.Equals(parameters.SortDirection, "desc", StringComparison.OrdinalIgnoreCase) ? -1 : 1;

            var sortField = parameters.SortBy.ToLower() switch
            {
                "title" => "title",
                "priority" => "priority",
                "status" => "status",
                "deadline" => "deadline",
                "scheduledat" => "scheduledAt",
                "headertitle" => "taskHeaderTitle",
                _ => "createdAt" // Default sort
            };

            pipeline.Add(new BsonDocument("$sort", new BsonDocument(sortField, sortDirection)));
        }
        else
        {
            // Default sort by created date (newest first)
            pipeline.Add(new BsonDocument("$sort", new BsonDocument("createdAt", -1)));
        }

        // Execute the aggregation
        var cursor = await _taskCollection.AggregateAsync<BsonDocument>(pipeline);
        var taskDocuments = await cursor.ToListAsync();

        // Map to DTOs
        var taskReadDtos = taskDocuments.Select(MapBsonDocumentToTaskReadDTO).ToList();

        return taskReadDtos;
    }

    private static TaskReadDTO MapBsonDocumentToTaskReadDTO(BsonDocument taskDocument)
    {
        return new TaskReadDTO
        {
            TaskId = taskDocument["_id"].AsObjectId.ToString(),
            TaskHeaderId = taskDocument["taskHeaderId"].AsObjectId.ToString(),
            TaskTitle = taskDocument["title"].AsString,
            TaskUri = taskDocument.Contains("uri") && !taskDocument["uri"].IsBsonNull
                ? taskDocument["uri"].AsString : null,
            TaskPriorityId = (byte)taskDocument["priority"].AsInt32,
            TaskStatusId = (byte)taskDocument["status"].AsInt32,
            Deadline = taskDocument.Contains("deadline") && !taskDocument["deadline"].IsBsonNull
            ? ParseDateTimeFromBsonDocument(taskDocument["deadline"].AsBsonDocument)
            : null,
            ScheduledAt = taskDocument.Contains("scheduledAt") && !taskDocument["scheduledAt"].IsBsonNull
            ? ParseDateTimeFromBsonDocument(taskDocument["scheduledAt"].AsBsonDocument)
            : null,
            DisplayAtBoard = taskDocument["displayAtBoard"].AsBoolean,
            TaskHeaderTitle = taskDocument["taskHeaderTitle"].AsString,
            Tags = taskDocument["tags"].AsBsonArray.Select(tag => tag.AsString).ToList(),

            // Map SubTasks
            SubTasks = taskDocument["subTasks"].AsBsonArray.Select(subTask => new SubTaskReadDto
            {
                SubTaskId = subTask["_id"].AsString, // _id is stored as GUID
                SubTaskTitle = subTask["subTaskTitle"].AsString,
                SubTaskUri = subTask.AsBsonDocument.Contains("subTaskUri") && !subTask["subTaskUri"].IsBsonNull
                    ? subTask["subTaskUri"].AsString : null
            }).ToList()
        };
    }

    private static DateTimeOffset ParseDateTimeFromBsonDocument(BsonDocument dateDoc)
    {
        var utcDateTime = dateDoc["DateTime"].ToUniversalTime();
        var offsetMinutes = dateDoc["Offset"].AsInt32;

        // Convert UTC time to local time based on the stored offset
        var localDateTime = DateTime.SpecifyKind(utcDateTime.AddMinutes(offsetMinutes), DateTimeKind.Unspecified);
        return new DateTimeOffset(localDateTime, TimeSpan.FromMinutes(offsetMinutes));
    }


    public async Task<bool> IsTaskExists(string taskId)
    {
        var task = await _taskCollection.Find(x => x.Id == taskId && x.DeletedAt == null).FirstOrDefaultAsync();
        return task != null;
    }

    public async Task DeleteTask(string taskId)
    {
        var filter = Builders<TaskItem>.Filter.Eq(x => x.Id, taskId);
        var update = Builders<TaskItem>.Update.Set(x => x.DeletedAt, DateTimeOffset.UtcNow);
        await _taskCollection.UpdateOneAsync(filter, update);
    }

    public async Task<IEnumerable<DisplayBoardTaskDto>> GetDisplayBoardTasksAsync()
    {
        // Get task where display at board is true and order it by deadline desc
        var filter = Builders<TaskItem>.Filter.And(
            Builders<TaskItem>.Filter.Eq(x => x.DeletedAt, null),
            Builders<TaskItem>.Filter.Eq(x => x.DisplayAtBoard, true)
        );
        var sort = Builders<TaskItem>.Sort.Descending(x => x.Deadline);

        var tasks = await _taskCollection
                    .Find(filter)
                    .Sort(sort)
                    .ToListAsync();
        return tasks.Select(
            t => new DisplayBoardTaskDto
            {
                TaskId = t.Id,
                TaskTitle = t.Title,
                TaskPriorityName = t.Priority.ToString(),
                TaskStatusName = t.Status.ToString(),
                ScheduledAt = t.ScheduledAt,
                Deadline = t.Deadline
            }
        ).ToList();
    }

    public async Task<IEnumerable<TaskStatusSelect>> GetTaskStatusesAsync()
    {
        var statuses = Enum.GetValues(typeof(Constants.TaskStatus))
         .Cast<Constants.TaskStatus>()
         .Select(status => new TaskStatusSelect(
             (byte)status,
             status.ToString()
         ));

        return await Task.FromResult(statuses);
    }

    public async Task<IEnumerable<TaskPrioritySelect>> GetTaskPrioritiesAsync()
    {
        var taskPriorities = Enum.GetValues(typeof(Constants.TaskPriority))
                 .Cast<Constants.TaskPriority>()
                 .Select(status => new TaskPrioritySelect(
                     (byte)status,
                     status.ToString()
                 ));

        return await Task.FromResult(taskPriorities);
    }

    public async Task<IEnumerable<TagReadDto>> GetAllTagsAsync()
    {
        var distinctTags = await _taskCollection
       .DistinctAsync<string>("tags", Builders<TaskItem>.Filter.Empty);

        var tagList = await distinctTags.ToListAsync();

        return tagList.Select(tag => new TagReadDto { TagName = tag });
    }
}

